<div class="main-container">
    <div class="canvas-container">
        <div class="controls-container">
            <div class="cycles-control">
                <label>Cycles: <span id="cyclesValue">2.0</span></label>
                <input type="range" id="cyclesSlider" min="0.5" max="10" step="0.5" value="2" class="slider">
            </div>
        </div>
        <canvas id="targetCanvas" width="800" height="200"></canvas>
    </div>

    <div class="canvas-container">
        <canvas id="attemptCanvas" width="800" height="200"></canvas>
    </div>

    <div class="navigation-controls">
        <button id="prevComponent" class="nav-button">&lt; Previous</button>
        <span id="componentNumber">Component 1 of X</span>
        <button id="nextComponent" class="nav-button">Next &gt;</button>
    </div>

    <div id="sliderContainer"></div>

    <div class="answer-container">
        <span id="answerString"></span>
        <button id="copyButton" class="copy-button">Copy</button>
    </div>
</div>

<script>
    var currentComponentIndex = 0;
    var lastModifiedHarmonic = null;
    var numCycles = 2;

    // Parse frequency string
    var frequencyString = '{{frequencies}}';
    var components = [];
    var userComponents = [];

    var activeIndicator = null;
    var indicatorTimeout = null;

    function modifyUserComponents(index, property, value) {
        userComponents[index][property] = value;
        drawAttempt();
        updateAnswerString();
        showFloatingValue(value, null, property);
    }

    function createFloatingIndicator() {
        const indicator = document.createElement('div');
        indicator.className = 'floating-indicator';
        return indicator;
    }

    function showFloatingValue(value, slider, type) {
        // Remove any existing indicator
        if (activeIndicator) {
            activeIndicator.remove();
        }
        clearTimeout(indicatorTimeout);

        // Create and position new indicator
        const indicator = createFloatingIndicator();
        const answerContainer = document.querySelector('.navigation-controls');
        answerContainer.appendChild(indicator);

        // Format the value based on type
        let displayValue;
        if (type === 'freq') {
            displayValue = value.toFixed(1) + 'Ã—';
        } else if (type === 'amp') {
            displayValue = value.toFixed(2);
        } else { // phase
            displayValue = (value).toFixed(2);
        }

        indicator.textContent = displayValue;
        indicator.style.opacity = '1';

        activeIndicator = indicator;

        // Hide after 1.5 seconds
        indicatorTimeout = setTimeout(() => {
            indicator.style.opacity = '0';
            setTimeout(() => indicator.remove(), 200);
        }, 1500);
    }

    function initializeComponents() {
        var compStrings = frequencyString.split(',');
        for (var i = 0; i < compStrings.length; i++) {
            var parts = compStrings[i].trim().split(' ');
            components.push({
                freq: parseFloat(parts[0]),
                amp: parseFloat(parts[1]),
                phase: parseFloat(parts[2])
            });
            var userComponentDefaultValues = {
                freq: 0,
                amp: 0,
                phase: 0
            };
            if (i === 0) {
                userComponentDefaultValues.freq = 1;
                userComponentDefaultValues.amp = 1;
                userComponentDefaultValues.phase = 0;
            }
            userComponents.push(userComponentDefaultValues);
        }
    }

    function setupCanvas(canvas) {
        var dpr = window.devicePixelRatio || 1;
        var rect = canvas.getBoundingClientRect();

        canvas.width = rect.width * dpr;
        canvas.height = rect.width * 0.25 * dpr;

        var ctx = canvas.getContext('2d');
        ctx.scale(dpr, dpr);
        return ctx;
    }

    function updateCycles() {
        numCycles = parseFloat(this.value);
        document.getElementById('cyclesValue').textContent = numCycles.toFixed(1);
        redrawAll();
    }

    function navigatePrev() {
        if (currentComponentIndex > 0) {
            currentComponentIndex--;
            updateComponentView();
        }
    }

    function navigateNext() {
        if (currentComponentIndex < components.length - 1) {
            currentComponentIndex++;
            updateComponentView();
        }
    }

    function updateComponentView() {
        document.getElementById('componentNumber').textContent =
            'Component ' + (currentComponentIndex + 1) + ' of ' + components.length;

        document.getElementById('prevComponent').disabled = currentComponentIndex === 0;
        document.getElementById('nextComponent').disabled = currentComponentIndex === components.length - 1;

        var container = document.getElementById('sliderContainer');
        container.innerHTML = '';
        container.appendChild(createComponent(currentComponentIndex));

        updateSliderValues();
    }

    function updateSliderValues() {
        var component = userComponents[currentComponentIndex];
        var container = document.querySelector('.component-container');

        container.querySelector('[data-control="freq"]').value = component.freq;
        container.querySelector('[data-control="amp"]').value = component.amp;
        container.querySelector('[data-control="phase"]').value = component.phase;

        var displays = container.getElementsByClassName('value-display');
        for (var i = 0; i < displays.length; i++) {
            var display = displays[i];
            var control = display.getAttribute('data-for');
            display.textContent = component[control].toFixed(2);
        }
    }

    function createComponent(index) {
        var div = document.createElement('div');
        div.className = 'component-container';

        var title = document.createElement('div');
        title.textContent = 'Component ' + (index + 1);
        title.style.fontWeight = 'bold';
        title.style.marginBottom = '10px';
        div.appendChild(title);

        var controls = [
            {name: 'freq', label: 'F', max: 10, step: 0.1},
            {name: 'amp', label: 'A', max: 1, step: 0.01},
            {name: 'phase', label: 'P', max: 1, step: 0.01}
        ];

        for (var i = 0; i < controls.length; i++) {
            var control = controls[i];
            var container = document.createElement('div');
            container.className = 'slider-container';

            var row = document.createElement('div');
            row.className = 'slider-row';

            // Minus button
            var minusBtn = document.createElement('button');
            minusBtn.className = 'adjust-button';
            minusBtn.textContent = '-';
            minusBtn.onclick = createAdjustHandler(index, control.name, -control.step);

            var label = document.createElement('span');
            label.className = 'slider-label';
            label.textContent = control.label + ':';

            var slider = document.createElement('input');
            slider.type = 'range';
            slider.className = 'slider';
            slider.min = 0;
            slider.max = control.max;
            slider.step = control.step;
            slider.value = userComponents[index][control.name];
            slider.setAttribute('data-control', control.name);
            slider.addEventListener('mousedown', createSliderHandler(index, control.name));
            slider.addEventListener('touchstart', createSliderHandler(index, control.name));
            slider.addEventListener('input', createSliderHandler(index, control.name));

            // Plus button (replaces value display)
            var plusBtn = document.createElement('button');
            plusBtn.className = 'adjust-button';
            plusBtn.textContent = '+';
            plusBtn.onclick = createAdjustHandler(index, control.name, control.step);

            row.appendChild(minusBtn);
            row.appendChild(label);
            row.appendChild(slider);
            row.appendChild(plusBtn);
            container.appendChild(row);
            div.appendChild(container);
        }

        return div;
    }

    function createAdjustHandler(index, controlName, step) {
        return function() {
            var slider = document.querySelector(`[data-control="${controlName}"]`);
            var currentValue = parseFloat(slider.value);
            var newValue = Math.min(Math.max(currentValue + step, slider.min), slider.max);
            slider.value = newValue;

            lastModifiedHarmonic = index;
            modifyUserComponents(index, controlName, newValue);

            // Clear lastModifiedHarmonic after a short delay
            setTimeout(() => {
                lastModifiedHarmonic = null;
                drawAttempt();
            }, 500);
        };
    }

    function createSliderHandler(index, controlName) {
        return function(event) {
            var newValue = parseFloat(this.value);
            lastModifiedHarmonic = index;
            modifyUserComponents(index, controlName, newValue);

            // Only clear lastModifiedHarmonic on mouseup/touchend
            const clearModified = () => {
                lastModifiedHarmonic = null;
                drawAttempt();
                document.removeEventListener('mouseup', clearModified);
                document.removeEventListener('touchend', clearModified);
            };

            // Add the listeners if they haven't been added yet
            if (event.type === 'mousedown' || event.type === 'touchstart') {
                document.addEventListener('mouseup', clearModified);
                document.addEventListener('touchend', clearModified);
            }
        };
    }

    function updateAnswerString() {
        var answer = userComponents.map(comp => {
            let freq = Number(comp.freq.toFixed(1)).toString();
            let amp = Number(comp.amp.toFixed(2)).toString();
            let phase = Number(comp.phase.toFixed(2)).toString();
            return `${freq} ${amp} ${phase}`;
        }).join(', ');
        document.getElementById('answerString').textContent = answer;
    }

    function initializeCopyButton() {
        document.getElementById('copyButton').onclick = function() {
            var text = document.getElementById('answerString').textContent;
            navigator.clipboard.writeText(text).then(function() {
                var originalText = this.textContent;
                this.textContent = 'Copied!';
                setTimeout(() => {
                    this.textContent = originalText;
                }, 1000);
            }.bind(this));
        };
    }

    function drawGridLines(canvas, ctx) {
        var rect = canvas.getBoundingClientRect();
        var cycleWidth = rect.width / numCycles;

        // Set initial grid style
        ctx.strokeStyle = '#ddd';
        ctx.lineWidth = 1;

        // Draw vertical cycle lines
        ctx.setLineDash([5, 5]);
        for (var i = 0; i <= numCycles; i++) {
            var x = i * cycleWidth;
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, rect.height);
            ctx.stroke();
        }

        // Draw horizontal amplitude lines
        // The canvas height represents amplitudes from -1 to 1
        // So we'll draw lines at each 0.1 interval
        var canvasHeight = rect.height;
        var centerY = canvasHeight / 2;
        var stepSize = (canvasHeight-20) / 20; // 20 steps for -1 to 1 in 0.1 increments

        for (var i = -10; i <= 10; i++) {
            var y = centerY + (i * stepSize);
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(rect.width, y);
            ctx.stroke();
        }

        // Reset dash setting
        ctx.setLineDash([]);
    }

    function drawWaveform(canvas, comps, colour, ctx) {
        var rect = canvas.getBoundingClientRect();

        // Calculate points
        var points = [];
        for (var x = 0; x < rect.width; x++) {
            points[x] = 0;
        }

        for (var i = 0; i < comps.length; i++) {
            var comp = comps[i];
            if (comp.freq === 0) continue;

            for (var x = 0; x < rect.width; x++) {
                var t = x * (Math.PI * 2 * numCycles / rect.width);
                points[x] += comp.amp * Math.sin(comp.freq * t + comp.phase * Math.PI * 2);
            }
        }

        var scale = (rect.height/2 - 20);

        // Draw waveform
        ctx.strokeStyle = colour;
        ctx.lineWidth = 2;
        ctx.beginPath();

        for (var x = 0; x < points.length; x++) {
            var scaledY = points[x] * scale + rect.height/2;
            if (x === 0) {
                ctx.moveTo(x, scaledY);
            } else {
                ctx.lineTo(x, scaledY);
            }
        }
        ctx.stroke();
    }

    function drawSingleHarmonic(canvas, component) {
        if (component.freq === 0) return;

        var ctx = canvas.getContext('2d');
        var rect = canvas.getBoundingClientRect();
        var points = [];

        for (var x = 0; x < rect.width; x++) {
            var t = x * (Math.PI * 2 * numCycles / rect.width);
            points[x] = component.amp * Math.sin(component.freq * t + component.phase * Math.PI * 2);
        }

        var scale = (rect.height/2 - 20);

        ctx.strokeStyle = '#888';
        ctx.lineWidth = 1;
        ctx.beginPath();

        for (var x = 0; x < points.length; x++) {
            var scaledY = points[x] * scale + rect.height/2;
            if (x === 0) {
                ctx.moveTo(x, scaledY);
            } else {
                ctx.lineTo(x, scaledY);
            }
        }
        ctx.stroke();
    }

    function drawAttempt() {
        var canvas = document.getElementById('attemptCanvas');
        var ctx = setupCanvas(canvas);

        // Clear and draw grid once
        var rect = canvas.getBoundingClientRect();
        ctx.clearRect(0, 0, rect.width, rect.height);
        drawGridLines(canvas, ctx);

        if (lastModifiedHarmonic !== null) {
            // First draw the sum of all components except the modified one in red
            var tempComponents = [...userComponents];
            var modifiedComponent = tempComponents[lastModifiedHarmonic];
            tempComponents[lastModifiedHarmonic] = { freq: 0, amp: 0, phase: 0 };
            drawWaveform(canvas, tempComponents, 'red', ctx);

            // Then draw the sum of all components in grey on top
            drawWaveform(canvas, userComponents, '#888', ctx);
        } else {
            // When no component is being modified, draw all components in red
            drawWaveform(canvas, userComponents, 'red', ctx);
        }
    }
    function redrawAll() {
        var targetCanvas = document.getElementById('targetCanvas');
        var ctx = setupCanvas(targetCanvas);
        var rect = targetCanvas.getBoundingClientRect();

        ctx.clearRect(0, 0, rect.width, rect.height);
        drawGridLines(targetCanvas, ctx);
        drawWaveform(document.getElementById('targetCanvas'), components, 'blue', ctx);
        drawAttempt();
    }

    // Initialize everything
    function init() {
        initializeComponents();

        document.getElementById('cyclesSlider').onchange = updateCycles;
        document.getElementById('cyclesSlider').oninput = updateCycles;
        document.getElementById('prevComponent').onclick = navigatePrev;
        document.getElementById('nextComponent').onclick = navigateNext;

        updateComponentView();
        redrawAll();
        updateAnswerString();
        initializeCopyButton();

        // Handle window resize
        var resizeTimer = null;
        window.onresize = function() {
            if (resizeTimer) {
                clearTimeout(resizeTimer);
            }
            resizeTimer = setTimeout(redrawAll, 250);
        };
    }

    // Start the application
    init();
</script>
<div>{{type::frequencies}}</div>
